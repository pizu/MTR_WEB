#!/usr/bin/env python3
# modules/html_builder/target_html.py
#
# Interactive Chart.js renderer with dual dropdowns:
#  - Metric: from settings.rrd.data_sources[].name
#  - Time Range: from settings.graph_time_ranges[].label
#
# Data source: static JSON generated by timeseries_exporter.py at:
#   html/data/<ip>_<label>.json
#
# Traceroute + Logs remain as before.

import os, re, html
from datetime import datetime
from modules.utils import setup_logger, resolve_html_dir
from modules.rrd_metrics import get_rrd_metrics
from modules.html_cleanup import resolve_html_dir_from_scripts


def generate_target_html(ip, description, hops, settings):
    logger = setup_logger("target_html", settings.get("log_directory", "/tmp"),
                          "target_html.log", settings=settings)

    HTML_DIR = resolve_html_dir(settings)                    # <— canonical site root
    DATA_DIR = os.path.join(HTML_DIR, "data")                # <— data under site root
    os.makedirs(DATA_DIR, exist_ok=True)

    LOG_DIR         = settings.get("log_directory", "logs")
    TRACEROUTE_DIR  = settings.get("traceroute_directory", "traceroute")
    REFRESH_SECONDS = settings.get("html_auto_refresh_seconds", 0)
    LOG_LINES_DISPLAY = settings.get("log_lines_display", 50)
    RRD_DIR         = settings.get("rrd_directory", "rrd")

    # Dropdown sources
    TIME_RANGES  = [r for r in settings.get("graph_time_ranges", []) if r.get("label")]
    METRICS      = [ds["name"] for ds in settings.get("rrd", {}).get("data_sources", [])]

    html_path = os.path.join(HTML_DIR, f"{ip}.html")
    log_path  = os.path.join(LOG_DIR, f"{ip}.log")
    trace_path= os.path.join(TRACEROUTE_DIR, f"{ip}.trace.txt")

    # Tail logs (newest on top)
    logs = []
    if os.path.exists(log_path):
        try:
            with open(log_path, encoding="utf-8") as f:
                logs = [line.strip() for line in f if line.strip()]
                logs = logs[-LOG_LINES_DISPLAY:][::-1]
        except Exception as e:
            logger.warning(f"Could not read logs for {ip}: {e}")

    traceroute = []
    if os.path.exists(trace_path):
        try:
            with open(trace_path, encoding="utf-8") as f:
                traceroute = f.read().splitlines()
        except Exception as e:
            logger.warning(f"Could not read traceroute for {ip}: {e}")

    hop0_metrics, _ = get_rrd_metrics(ip, RRD_DIR, METRICS)

    os.makedirs(HTML_DIR, exist_ok=True)
    try:
        with open(html_path, "w", encoding="utf-8") as f:
            f.write("<!doctype html><html><head><meta charset='utf-8'>")
            if REFRESH_SECONDS > 0:
                f.write(f"<meta http-equiv='refresh' content='{REFRESH_SECONDS}'>")
            f.write(f"<title>{ip}</title>")
            f.write("""
<style>/* …(styles unchanged)… */</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <h1>Interactive MTR Graph — """ + html.escape(ip) + """</h1>
      <p>Hover for tooltips; click legend chips to toggle; Alt+click to solo.</p>
    </header>
    <div class="toolbar">
      <div>
        <label for="metric">Metric:</label>
        <select id="metric"></select>
      </div>
      <div>
        <label for="range">Time Range:</label>
        <select id="range"></select>
      </div>
      <div class="note">Data from RRD; labels from traceroute.</div>
    </div>
    <div class="panel">
      <div class="chart-container"><canvas id="mtrChart"></canvas></div>
      <div id="legend" class="legend" aria-label="Hop legend"></div>
      <div class="note">""" + ("; ".join(f"{k}: {v}" for k, v in (hop0_metrics or {}).items()) if hop0_metrics else "") + """</div>
    </div>
  </div>

  <h3>Traceroute</h3>
  <table><tr><th>Hop</th><th>Address</th><th>Details</th></tr>""")

            # traceroute table (same as before)
            for idx, line in enumerate(traceroute, start=1):
                parts = line.strip().split()
                hop_ip = parts[1] if len(parts) >= 2 else "???"
                latency = parts[2] + " " + parts[3] if len(parts) > 3 else (parts[2] if len(parts) > 2 else "-")
                if hop_ip == "???" or hop_ip.lower() == "request" or hop_ip == "Request":
                    hop_ip = "Request timed out"
                    latency = "-"
                f.write(f"<tr><td>{idx}</td><td>{html.escape(hop_ip)}</td><td>{html.escape(latency)}</td></tr>")
            f.write("</table>")

            # logs
            f.write("""
  <h3>Recent Logs</h3>
  <input type="text" id="logFilter" placeholder="Filter logs..." style="width:100%;margin-bottom:10px;padding:5px;">
  <table class="log-table"><thead><tr><th>Timestamp</th><th>Level</th><th>Message</th></tr></thead><tbody>""")
            log_line_re = re.compile(r"^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}) \[(\w+)\] (.*)")
            for line in logs:
                m = log_line_re.match(line)
                ts, level, msg = m.groups() if m else ("", "", line)
                color = {
                    "DEBUG": "color:#94a3b8;",
                    "INFO": "color:#86efac;",
                    "WARNING": "color:#fbbf24;",
                    "ERROR": "color:#f87171;"
                }.get((level or "").upper(), "color:#e5e7eb;")
                f.write(f"<tr class='log-line'><td>{ts}</td><td style='{color}'>{html.escape(level)}</td><td><pre>{html.escape(msg)}</pre></td></tr>")
            f.write("""</tbody></table>

  <p class="note">Generated: """ + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + """ — """ + ("Auto-refresh enabled" if REFRESH_SECONDS > 0 else "Auto-refresh disabled") + """</p>
  <p><a href="index.html" style="color:#93c5fd">Back to index</a></p>
</div>

<script>
const METRICS = """ + json_escape_js_array(METRICS := METRICS) + """;
const RANGES  = """ + json_escape_js_array([r["label"] for r in TIME_RANGES]) + """;
const DATA_DIR = "data";                  // relative to HTML_DIR
const IP = """ + json_quote(ip) + """;

const metricSel = document.getElementById('metric');
const rangeSel  = document.getElementById('range');
const legendEl  = document.getElementById('legend');
const ctx = document.getElementById('mtrChart').getContext('2d');

function fillSelect(sel, arr) {
  sel.innerHTML = '';
  arr.forEach((v,i) => {
    const opt = document.createElement('option');
    opt.value = v; opt.textContent = v.toUpperCase();
    sel.appendChild(opt);
  });
  sel.selectedIndex = 0;
}

function buildDatasetsFromBundle(bundle, metric) {
  return (bundle.hops || []).map(h => ({
    label: h.name,
    data: (h.metrics && h.metrics[metric]) ? h.metrics[metric] : [],
    borderColor: h.color || '#888',
    backgroundColor: h.color || '#888',
    spanGaps: true,
    borderWidth: 2,
    pointRadius: 2,
    tension: 0.25,
    hidden: false,
    yAxisID: metric === 'loss' ? 'yLoss' : 'yLatency'
  }));
}

let currentBundle = null;
let currentMetric = null;
let chart = new Chart(ctx, {
  type: 'line',
  data: { labels: [], datasets: [] },
  options: {
    responsive: true, maintainAspectRatio: false,
    interaction: { mode: 'nearest', intersect: false },
    plugins: {
      tooltip: {
        callbacks: {
          title: (items) => items[0]?.label || '',
          label: (item) => {
            const dsLabel = item.dataset.label;
            const val = item.parsed.y;
            const unit = currentMetric === 'loss' ? '%' : ' ms';
            return `${dsLabel} — ${val}${unit}`;
          }
        }
      },
      legend: { display: false }
    },
    scales: {
      x: { grid: { color: '#1f2937' }, ticks: { color: '#cbd5e1' } },
      yLatency: {
        type: 'linear', position: 'left',
        grid: { color: '#1f2937' }, ticks: { color: '#cbd5e1' },
        title: { display: true, text: 'Latency (ms)' }
      },
      yLoss: {
        type: 'linear', position: 'right',
        grid: { drawOnChartArea: false }, ticks: { color: '#cbd5e1', callback: (v)=> v + '%' },
        title: { display: true, text: 'Loss (%)' }, min: 0, max: 100
      }
    }
  }
});

function renderLegend() {
  legendEl.innerHTML = '';
  chart.data.datasets.forEach((ds, idx) => {
    const item = document.createElement('button');
    item.className = 'item' + (ds.hidden ? ' dim' : '');
    item.title = ds.label;
    item.onclick = (ev) => {
      if (ev.altKey) {
        const visible = chart.data.datasets.filter(d=>!d.hidden);
        const soloHidden = (visible.length === 1 && !ds.hidden);
        chart.data.datasets.forEach((d,i)=> d.hidden = soloHidden ? false : (i !== idx));
      } else {
        ds.hidden = !ds.hidden;
      }
      chart.update(); renderLegend();
    };
    const swatch = document.createElement('span'); swatch.className = 'swatch';
    swatch.style.backgroundColor = ds.borderColor;
    const label = document.createElement('span'); label.textContent = ds.label;
    item.appendChild(swatch); item.appendChild(label);
    legendEl.appendChild(item);
  });
}

function fmtTime(epoch) {
  const d = new Date(epoch * 1000);
  return d.toLocaleString();
}

async function loadBundle(rangeLabel) {
  const url = `${DATA_DIR}/${IP}_${rangeLabel}.json?t=${Date.now()}`; // cache-buster
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`fetch failed: ${url}`);
  currentBundle = await res.json();

  // update x-axis labels
  chart.data.labels = currentBundle.timestamps || [];

  // show last updated (from the last epoch in the bundle)
  const last = (currentBundle.epoch && currentBundle.epoch.length)
    ? currentBundle.epoch[currentBundle.epoch.length - 1]
    : null;
  const noteEl = document.querySelector('.note');
  if (noteEl && last) {
    noteEl.textContent = `Last updated: ${fmtTime(last)} (range: ${currentBundle.label})`;
  }

  // Keep current metric if possible; else fall back
  const wanted = currentMetric && METRICS.includes(currentMetric) ? currentMetric : (METRICS[0] || 'avg');
  setMetric(wanted);
}

function setMetric(metric) {
  currentMetric = metric;
  chart.data.datasets = buildDatasetsFromBundle(currentBundle || {}, metric);
  chart.update(); renderLegend();
}

function onMetricChange() { setMetric(metricSel.value); }
async function onRangeChange() { await loadBundle(rangeSel.value); }

function filterLogs() {
  const input = document.getElementById('logFilter').value.toLowerCase();
  const lines = document.getElementsByClassName('log-line');
  for (const line of lines) {
    line.style.display = line.innerText.toLowerCase().includes(input) ? '' : 'none';
  }
}

// initialize
fillSelect(metricSel, METRICS);
fillSelect(rangeSel, RANGES);
metricSel.addEventListener('change', onMetricChange);
rangeSel.addEventListener('change', onRangeChange);
onRangeChange();  // load first bundle
</script>
</body></html>""")

        logger.info(f"Generated interactive HTML for {ip}")
    except Exception:
        logger.exception(f"[{ip}] Failed to generate target HTML")

def json_quote(s: str) -> str:
    return '"' + (s or "").replace('"', '\\"') + '"'

def json_escape_js_array(arr):
    out = []
    for v in arr:
        if v is None: continue
        s = str(v).replace("\\", "\\\\").replace('"','\\"')
        out.append('"' + s + '"')
    return "[" + ",".join(out) + "]"
