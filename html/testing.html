<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MTR_WEB – <span id="page-ip">Target</span></title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart.js (no custom colors/styles; you can theme later) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    header { display:flex; align-items:baseline; gap:12px; margin-bottom: 12px; }
    .muted { color:#666; font-size: 0.95rem; }
    .row { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 1100px) { .row { grid-template-columns: 1.2fr 0.8fr; } }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:12px 14px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .card h3 { margin: 6px 0 12px; font-size: 1.05rem; }
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin: 8px 0 12px; }
    .toolbar .pill { padding:6px 10px; border:1px solid #d1d5db; border-radius:999px; background:#fff; cursor:pointer; }
    .pill.active { background:#111827; color:#fff; border-color:#111827; }
    .kv { display:flex; gap:8px; flex-wrap:wrap; }
    .kv span { background:#f3f4f6; border-radius:8px; padding:4px 8px; font-size:12px; }
    .logbox { background:#0b1020; color:#b3c7ff; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:10px; border-radius:8px; min-height: 120px; overflow:auto; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:6px 8px; border-bottom: 1px solid #eee; text-align:left; font-size: 0.95rem; }
    th { background:#fafafa; position: sticky; top:0; }
    .btn { padding:6px 10px; border:1px solid #d1d5db; border-radius:8px; background:#fff; cursor:pointer; }
    .grid2 { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 900px) { .grid2 { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <header>
    <h1 id="title">Target <code id="ip"></code></h1>
    <div class="muted" id="desc"></div>
  </header>

  <!-- Controls -->
  <section class="card">
    <div class="toolbar">
      <strong>Time range:</strong>
      <!-- Ranges should match mtr_script_settings.yaml -> html.ranges (example) -->
      <button class="pill active" data-range="1h">1h</button>
      <button class="pill" data-range="6h">6h</button>
      <button class="pill" data-range="12h">12h</button>
      <button class="pill" data-range="24h">24h</button>
      <button class="pill" data-range="1w">1w</button>
      <span class="muted" id="last-update"></span>
    </div>
    <div class="kv" id="status-line"></div>
  </section>

  <div class="row">
    <!-- Left: main time-series -->
    <section class="card">
      <h3>Latency over time (per hop)</h3>
      <canvas id="latencyChart" height="180"></canvas>
      <div class="muted">Shows hop latencies across the selected time window (from RRD→JSON).</div>
    </section>

    <!-- Right: snapshot / traceroute -->
    <section class="card">
      <h3>Current snapshot (per hop)</h3>
      <div class="toolbar">
        <button class="btn" id="refreshSnapshot">Refresh snapshot</button>
      </div>
      <canvas id="snapshotLatency" height="220"></canvas>
      <div class="muted">One bar per hop (latest point). Useful to spot where delay starts.</div>
    </section>
  </div>

  <div class="grid2" style="margin-top:16px;">
    <section class="card">
      <h3>Traceroute path</h3>
      <table id="trTable">
        <thead><tr><th>#</th><th>Hop</th><th>Hostname</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="muted">Hops are loaded from <code>traceroute/&lt;ip&gt;_hops.json</code>.</div>
    </section>

    <section class="card">
      <h3>Latest log excerpt</h3>
      <div class="logbox" id="logbox">(log excerpt placeholder if you export one)</div>
      <div class="muted">You can wire this to the last X log lines per target based on <code>mtr_script_settings.yaml</code>.</div>
    </section>
  </div>

<script>
/**
 * ======= HOW THIS PAGE WIRES TO YOUR PROJECT =======
 *
 * Paths (adjust if your layout differs):
 *   DATA JSON:     html/data/<ip>_<range>.json
 *   HOPS JSON:     traceroute/<ip>_hops.json
 *   HOPS STATS:    traceroute/<ip>_hops_stats.json   (optional, if you want to show stats)
 *
 * Expected DATA JSON shape (example):
 * {
 *   "ip": "8.8.8.8",
 *   "label": "1h",
 *   "seconds": 3600,
 *   "step": 60,
 *   "timestamps": ["17:28","17:29", ...],
 *   "series": [
 *     { "hop": 0, "label": "1.2.3.4", "avg": [..], "last":[..], "best":[..], "loss":[..] },
 *     { "hop": 1, "label": "2.3.4.5", "avg": [..], "last":[..], "best":[..], "loss":[..] },
 *     ...
 *   ]
 * }
 *
 * If your JSON uses different keys, adapt the "extractSeries" function below.
 *
 * IMPORTANT: Colors are default Chart.js (as per your constraint).
 */

 // --- CONFIG (set by your generator) ---
 const TARGET_IP = (new URLSearchParams(location.search)).get('ip') || document.location.pathname.split('/').filter(Boolean).pop() || '8.8.8.8';
 const DATA_BASE = '../data';        // relative from html/<ip>/index.html -> html/data/
 const TRACE_BASE = '../../traceroute'; // relative from html/<ip>/index.html -> traceroute/
 const DEFAULT_RANGE = '1h';

 // UI references
 const ipEl = document.getElementById('ip');
 const pageIpEl = document.getElementById('page-ip');
 const descEl = document.getElementById('desc');
 const statusLine = document.getElementById('status-line');
 const lastUpdateEl = document.getElementById('last-update');
 const trTableBody = document.querySelector('#trTable tbody');

 ipEl.textContent = TARGET_IP;
 pageIpEl.textContent = TARGET_IP;

 // Example: if your generator writes a description to a sidecar JSON or injects into the page,
 // you can set it programmatically. For now, leave empty or fill from _hops.json if it has a "description".
 descEl.textContent = '';

 // State
 let currentRange = DEFAULT_RANGE;
 let latencyChart, snapshotChart;

 // Helper: fetch JSON
 async function getJSON(url) {
   const res = await fetch(url, { cache: 'no-store' });
   if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
   return res.json();
 }

 // Build file paths
 function dataPath(range) { return `${DATA_BASE}/${TARGET_IP}_${range}.json`; }
 function hopsPath() { return `${TRACE_BASE}/${TARGET_IP}_hops.json`; }
 function hopsStatsPath() { return `${TRACE_BASE}/${TARGET_IP}_hops_stats.json`; }

 // Extract data for time-series chart
 function extractSeries(json) {
   // If your JSON structure differs, adapt mapping here.
   const labels = json.timestamps || [];
   const datasets = [];

   // Prefer "series" as an array; fallback: derive from other keys if you used another layout.
   (json.series || []).forEach((hopObj, idx) => {
     // Here we choose which metric to display on the main time-series:
     // You can switch 'avg' => 'last' if preferred, or duplicate charts.
     const data = hopObj.avg || hopObj.last || [];
     datasets.push({
       label: `hop ${hopObj.hop} • ${hopObj.label || ''}`.trim(),
       data,
       borderWidth: 1,
       pointRadius: 0,
       tension: 0.2 // light smoothing
     });
   });

   return { labels, datasets };
 }

 // Latest “snapshot” (horizontal bar) from the last point in each hop’s array
 function extractSnapshot(json) {
   const labels = [];
   const data = [];
   (json.series || []).forEach(hopObj => {
     const arr = hopObj.avg || hopObj.last || [];
     const latest = arr.length ? arr[arr.length - 1] : null;
     labels.push(`h${hopObj.hop} ${hopObj.label || ''}`.trim());
     data.push(latest ?? null);
   });
   return { labels, data };
 }

 // Build / update time-series chart
 function renderLatencyChart(series) {
   const ctx = document.getElementById('latencyChart').getContext('2d');
   if (latencyChart) latencyChart.destroy();
   latencyChart = new Chart(ctx, {
     type: 'line',
     data: {
       labels: series.labels,
       datasets: series.datasets
     },
     options: {
       animation: false,
       responsive: true,
       maintainAspectRatio: false,
       scales: {
         x: { title: { display: true, text: 'time' } },
         y: { title: { display: true, text: 'latency (ms)' }, beginAtZero: true }
       },
       interaction: { mode: 'nearest', intersect: false },
       plugins: {
         legend: { position: 'bottom' },
         tooltip: { callbacks: {
           // helpful to show hop label cleanly
           title: (ctx) => `Time: ${ctx[0]?.label ?? ''}`
         }}
       }
     }
   });
 }

 // Build / update horizontal snapshot
 function renderSnapshotChart(snap) {
   const ctx = document.getElementById('snapshotLatency').getContext('2d');
   if (snapshotChart) snapshotChart.destroy();
   snapshotChart = new Chart(ctx, {
     type: 'bar',
     data: {
       labels: snap.labels,
       datasets: [{
         label: 'latest avg latency (ms)',
         data: snap.data
       }]
     },
     options: {
       indexAxis: 'y',
       animation: false,
       responsive: true,
       maintainAspectRatio: false,
       scales: {
         x: { title: { display: true, text: 'ms' }, beginAtZero: true }
       },
       plugins: {
         legend: { display: true },
         tooltip: { callbacks: {
           label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.x ?? 'n/a'} ms`
         }}
       }
     }
   });
 }

 // Render traceroute hop table (from *_hops.json)
 function renderTracerouteTable(hopsJson) {
   trTableBody.innerHTML = '';
   const hops = hopsJson?.hops || hopsJson || []; // support either {hops:[...]} or plain array
   hops.forEach((h, i) => {
     const tr = document.createElement('tr');
     const tdIdx = document.createElement('td'); tdIdx.textContent = i;
     const tdIp = document.createElement('td'); tdIp.textContent = h.ip || h.addr || h.host || '';
     const tdName = document.createElement('td'); tdName.textContent = h.name || h.hostname || '';
     tr.appendChild(tdIdx); tr.appendChild(tdIp); tr.appendChild(tdName);
     trTableBody.appendChild(tr);
   });
 }

 // Status line from JSON metadata (optional)
 function renderStatus(json) {
   statusLine.innerHTML = '';
   const parts = [];
   if (json?.label) parts.push(`range: ${json.label}`);
   if (json?.seconds) parts.push(`window: ${json.seconds}s`);
   if (json?.step) parts.push(`step: ${json.step}s`);
   if (json?.series?.length) parts.push(`hops: ${json.series.length}`);
   parts.forEach(p => {
     const span = document.createElement('span');
     span.textContent = p;
     statusLine.appendChild(span);
   });
   lastUpdateEl.textContent = `updated at ${new Date().toLocaleTimeString()}`;
 }

 // Load everything for current range
 async function loadRange(range) {
   try {
     const json = await getJSON(dataPath(range));
     const series = extractSeries(json);
     renderLatencyChart(series);
     renderStatus(json);
   } catch (e) {
     console.error(e);
     alert(`Failed loading range data: ${range}`);
   }
 }

 // Refresh snapshot from the SAME range file (using latest point)
 async function refreshSnapshot() {
   try {
     const json = await getJSON(dataPath(currentRange));
     const snap = extractSnapshot(json);
     renderSnapshotChart(snap);
   } catch (e) {
     console.error(e);
     alert(`Failed refreshing snapshot`);
   }
 }

 // Load traceroute table from *_hops.json
 async function loadTraceroute() {
   try {
     const hops = await getJSON(hopsPath());
     renderTracerouteTable(hops);
     // Optional: if hops JSON includes "description" (you mentioned adding it in mtr_targets.yaml),
     // show it under the page title:
     if (hops?.description && !descEl.textContent) {
       descEl.textContent = hops.description;
     }
   } catch (e) {
     console.warn('No traceroute JSON yet:', e.message);
   }
 }

 // Wire range buttons
 document.querySelectorAll('.pill').forEach(btn => {
   btn.addEventListener('click', () => {
     document.querySelectorAll('.pill').forEach(b => b.classList.remove('active'));
     btn.classList.add('active');
     currentRange = btn.dataset.range;
     loadRange(currentRange);
     refreshSnapshot();
   });
 });

 document.getElementById('refreshSnapshot').addEventListener('click', refreshSnapshot);

 // Initial load
 loadRange(currentRange);
 refreshSnapshot();
 loadTraceroute();
</script>
</body>
</html>
